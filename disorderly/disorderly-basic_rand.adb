
-------------------------------------------------------------------------------
-- package body Disorderly.Basic_Rand, Linear Random Number Generator
-- Copyright (C) 1995-2018 Jonathan S. Parker
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted, provided that the above
-- copyright notice and this permission notice appear in all copies.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-------------------------------------------------------------------------------

with Text_Utilities;
with XOR_Shift;
with LCG_Rand;

package body Disorderly.Basic_Rand
   with Spark_Mode => On
is

  package Text_Handling is new Text_Utilities (No_Of_Seeds, Parent_Random_Int);
  use Text_Handling;

  package MWC is new LCG_Rand (Parent_Random_Int);
  use MWC;

  package Xor_Rand is new XOR_Shift (Parent_Random_Int);
  use Xor_Rand;

  --  The state (composed of 3 x 64 bits) is contained in an array of 3
  --  64 bit ints indexed by the following 3 ints:

  LCG_id_0     : constant State_Index := 0;
  LCG_id_1     : constant State_Index := 1;
  Xor_Shift_id : constant State_Index := 2;

  ----------------
  -- Get_Random --
  ----------------

  --  Get_Random is a combination generator: 2 component generators x, and y
  --  are combined to produce a generator z whose period is the product of
  --  the periods of x, and y.  z is generated by z = (x + y) mod p,
  --  where y is full period in range 0..p-1, and the periods of the
  --  generators for x and y have no prime factors in common.
  --  Only one of the two generators x and y
  --  needs to be full-period to guarantee a full-period z.

  procedure Get_Random
    (Random_x :    out Random_Int;
     S        : in out State)
  is
     X1, X2 : Parent_Random_Int;
     S0, S1 : Parent_Random_Int;
  begin
     S0 := S.X(LCG_id_0);
     S1 := S.X(LCG_id_1);
     Get_Random_LCG_64_Combined (S0, S1, X1);
     S.X(LCG_id_0) := S0;
     S.X(LCG_id_1) := S1;

     X2 := S.X(XOR_Shift_Id);
     Get_Random_XOR_Shift_61 (X2);
     S.X(XOR_Shift_Id) := X2;

     Random_x := Random_Int ((X1 + X2) mod 2**61);

  end Get_Random;

  --subtype Valid_LCG_0_Range     is Parent_Random_Int range 1 .. m0 - 1;
  --subtype Valid_LCG_1_Range     is Parent_Random_Int range 1 .. m1 - 1;
  --subtype Valid_XOR_Shift_Range is Parent_Random_Int range 1 .. 2**61 - 1;

  function Valid_State (S : in State) return Boolean is
     Result : constant Boolean :=
       (S.X(LCG_id_0)     in Valid_LCG_0_Range) and
       (S.X(LCG_id_1)     in Valid_LCG_1_Range) and
       (S.X(Xor_Shift_id) in Valid_Xor_Shift_Range);
  begin
     return Result;
  end Valid_State;

  procedure Make_Correct (S : in out State) is
  begin

     if S.X(LCG_id_0)  > Valid_LCG_0_Range'Last then
        S.X(LCG_id_0) := Valid_LCG_0_Range'Last;
     end if;

     if S.X(LCG_id_0)  < Valid_LCG_0_Range'First then -- Period=1 if = 0
        S.X(LCG_id_0) := Valid_LCG_0_Range'First;
     end if;

     if S.X(LCG_id_1)  > Valid_LCG_1_Range'Last then
        S.X(LCG_id_1) := Valid_LCG_1_Range'Last;
     end if;

     if S.X(LCG_id_1)  < Valid_LCG_1_Range'First then -- Period=1 if = 0
        S.X(LCG_id_1) := Valid_LCG_1_Range'First;
     end if;

     if S.X(Xor_Shift_id)  > Valid_Xor_Shift_Range'Last then
        S.X(Xor_Shift_id) := Valid_Xor_Shift_Range'Last;
     end if;

     if S.X(Xor_Shift_id)  < Valid_Xor_Shift_Range'First then
        S.X(Xor_Shift_id) := Valid_Xor_Shift_Range'First;
     end if;

  end Make_Correct;

  -----------
  -- Reset --
  -----------

  -- Step 1. Guarantee that each unique and valid choice
  -- of the Initiators (Initiator1, Initiator2, .. )
  -- produces a unique and valid initial state S: S.X(0), S.X(1), ...
  --
  -- Step 2. Guarantee that a change of 1 bit or more in any one Initiator
  -- will cause changes in all elements of the initial state S: S.X(0), S.X(1), ...
  --
  procedure Reset
    (S          :    out State;
     Initiator1 : in     Seed_Random_Int := 1111;
     Initiator2 : in     Seed_Random_Int := 2222;
     Initiator3 : in     Seed_Random_Int := 3333)
  is
     Seeds : Vals := (Initiator1, Initiator2, Initiator3);

     Cut, Seed : Parent_Random_Int;
     Cut_Shift_Length : constant Integer := (1 + Bits_per_Random_Number / S.X'Length);

     --  the transpose requires:

     pragma Assert (State_Index'First = 0);
     pragma Assert (S.X'Length < 9);
     pragma Assert (Bits_per_Random_Number = 61);
     pragma Assert (Random_Int'Last = 2**Bits_per_Random_Number-1);
  begin

     for Keep_Trying in 1 .. 17 loop  -- arbitrary loop limit. More is good.

        -- Step 1:
        -- Start by transforming each seed with a function
        -- that is a 1-1 mapping between all elements of 0..2**61-1.
        -- (0 maps to 0, but is weeded out).

        for i in State_Index loop
           Get_Random_XOR_Shift_61_b (Seeds(i));
        end loop;

        -- Step 2:
        -- Make an N x N matrix out of the N elements of array Seed
        -- (by breaking each element into N Parts), and transpose it;
        -- write it to to the state S.X:

        S.X := (others => 0);

        for j in State_Index loop

           Seed := Seeds(j);

           for i in State_Index loop
              Cut    := Seed mod 2**Cut_Shift_Length;
              S.X(i) := S.X(i) + Cut * 2**(j*Cut_Shift_Length);
              Seed   := Seed / 2**Cut_Shift_Length;
           end loop;

        end loop;

        -- Scramble the state S.X again:

        for i in State_Index loop
           Get_Random_XOR_Shift_61_b (S.X(i));
        end loop;

        Seeds := S.X; -- use the new seeds and scramble again.

     end loop;

     -- Notice each S.X is in 0..2^61-1, so have S.X < a0 * b0 - 1 etc.
     -- Still may have S.X = 0, which gives period of 1 to component generators.

     -- Step 3: Error Correction.

     if not Valid_State (S) then
        Make_Correct (S);
     end if;

  end Reset;

  -----------
  -- Value --
  -----------

  function Value (Coded_State : in State_String) return State is
     S  : State;
     Seed_1_1st : constant Positive := Coded_State'First;
     Seed_j_1st : Positive;
  begin

     for j in State_Index loop
        Seed_j_1st  := Seed_1_1st  + (j-State_Index'First) * Rand_Image_Width;
        S.X(j) := Value (Coded_State(Seed_j_1st .. Seed_j_1st + Rand_Image_Width - 1));
     end loop;

     return S;

  end Value;

  -----------
  -- Image --
  -----------

  function Image (Of_State : State) return State_String is
     Result : State_String := (others => '0');
     Y : Random_Int_String;
     Seed_1_1st : constant Positive := Result'First;
     Seed_j_1st : Positive;
  begin

     for j in State_Index loop
        Y := Image (Of_State.X (j));
        Seed_j_1st  := Seed_1_1st  + (j-State_Index'First) * Rand_Image_Width;
        Result(Seed_j_1st .. Seed_j_1st+Rand_Image_Width-1) := Y;
     end loop;

     return Result;
  end Image;

  -- Puts a ' ' in front of each 20 digit number.

  function Formatted_Image_Of (Of_State : State_String) return Formatted_State_String is
     Result : Formatted_State_String := (others => ' ');
     Seed_1_1st : constant Positive := Result'First;
     Seed_y_1st, Seed_j_1st : Positive;
     Y : Random_Int_String;
  begin
     for j in State_Index loop
        Seed_j_1st := Seed_1_1st + (j-State_Index'First) * (Rand_Image_Width + Leading_Spaces);
        Seed_y_1st := Seed_1_1st + (j-State_Index'First) *  Rand_Image_Width;
        Y := Of_State(Seed_y_1st .. Seed_y_1st+Rand_Image_Width-1);
        Result(Seed_j_1st .. Seed_j_1st+Rand_Image_Width-1) := Y;
     end loop;

     return Result;
  end Formatted_Image_Of;

  function Formatted_Image (Of_State : State) return Formatted_State_String is
  begin
     return Formatted_Image_Of (Image (Of_State));
  end Formatted_Image;

  function Are_Equal (State_1, State_2 : State) return Boolean is
     Result : Boolean := True;
  begin
     for i in State_1.X'Range loop
        if State_1.X(i) /= State_2.X(i) then Result := False; end if;
     end loop;
     return Result;
  end Are_Equal;
       
end Disorderly.Basic_Rand;

