
-------------------------------------------------------------------------------
-- package Disorderly.Random.Deviates, Floating point random deviates.
-- Copyright (C) 1995-2018 Jonathan S. Parker
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted, provided that the above
-- copyright notice and this permission notice appear in all copies.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-------------------------------------------------------------------------------

-- PACKAGE Disorderly.Random.Deviates
--
-- Generates floating point streams of Random deviates (variates) from
-- the following distributions:
--
--   Uniform, Normal (Gaussian), Exponential, Lorentzian (Cauchy),
--   Poissonian, Binomial, Negative Binomial, Weibull, Rayleigh, 
--   Student_t, Beta, Gamma, Chi_Squared, Log_Normal, Multivariate_Normal
--
-- The more complicated deviates are accompanied by routines that
-- calculate their respective probability densities. The test routine,
-- (deviates_demo_1), verifies that the random variables are
-- drawn from these probability distributions, as advertized.
--
-- So deviates_demo_1.adb is a useful demonstration of the
-- random  variable generators in this package, as well as the exact
-- distributions they are drawn from.
--
-- The package is pure.
--
-- Most routines would grind to a halt if they had to recalculate
-- certain quantities each call.  So these quantities are calculated
-- on the first call, and then placed into a record that's passed
-- as in/out parameter to keep the package pure.
--
-- Uses 53 bits of the 61-bit generator Disorderly.Random.
--
-- For most of the routines, the time_per_call is not constant.  Most 
-- routines call the random number generator an unpredictable number 
-- of times each time the routine is called.
--
-- Wikipedia gives extended descriptions of each distribution. The
-- probability density functions generated by the functions declared 
-- below are taken directly from the Wikipedia articles on the same,
-- to ensure that the Wikipedia discussions are exactly relevant.
--  
-- Uses the integer valued Disorderly.Random in the parent package to
-- create a floating point generator (Uniform).
-- Is generic in the floating point type (as long as its 15 digits!).
--
-- Like the other routines in this collection, Deviates is designed
-- to exploit the newer 64-bit CPU's. All of the routines use
-- 15 digit floats, which means 53 bit mantissas in practice.
-- Poisson should be thought of as single precision though.
--
-- References:
--
-- Chandrasekaran and Sheppard,
-- Journal of Pascal, Ada, and Modula2, Vol 5, Num 4, (1986).
--
-- Kemp, C.D. (1986). 'A modal method for generating binomial
-- variables', Commun. Statist. - Theor. Meth. 15(3), 805-813.
--
-- see also Fortran 77 code from the book:
-- Dagpunar, J. 'Principles of random variate generation'
-- Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9
--
-- Many thanks are due to Allan Miller - most routines are based on
-- his Fortran 90 versions of the Dagpunar code.
--
-- Notes on the Distributions:
--
-- The functions approximate in a statistical manner certain continuous
-- probability distributions or densities (except Poisson and the Binomials, 
-- which are integer valued here, not continuous).  More precisely, if
-- you ran the program a long time, added up the number of points output
-- in each interval (X,X+dX), and plotted the resulting histogram,
-- you would get a function f(X), where f(X) is given as follows.
-- The functions are given in Normalized form.
--
-- The easy ones:  
--  
--  Random_Real (X, State_Val) samples from a uniform distribution: 
--         = 1 for 0.0 <= X < 1.0
--         = 0 otherwise.
--
--  Exponential (Mean)  = Exp (-X / Mean) / Mean for X > 0; 0 otherwise.
--
--  Normal (Mean, Sigma) =
--         = Exp (-(X - Mean)**2 / (2*Sigma**2)) / (Sigma*Sqrt(2*Pi))
--  
--    Sometimes Normal is called Gaussian   if Mean /=0 and Std Dev /= 1.
--    Sometimes Normal is called Std Normal if Mean  =0 and Std Dev  = 1.
--
--  Poisson (Mean) = Mean**k * Exp (-Mean) / k!
--
--    Output of Poisson is integer valued; Output includes 0.
--
-- The Cauchy probability density has a Lorentzian shape: (a/pi) / (a^2 + X^2). 
--
-- The more complicated distribution are described well in their
-- respective Wikipedia articles.

generic

   type Real is digits <>;
   --  15 digits required.  This is checked.
   
package Disorderly.Random.Deviates is

   pragma Pure (Deviates);

   procedure Get_Random_Real
     (Random_Real : out    Real;
      Stream      : in out State);
   --
   --  Uniform on [0.0, 1.0).  
   --  (X starts out on 0..2**53-1; then squeezed onto [0,1) by 
   --  multiplying X by 2.0**(-53).)


   type Normal_Initializer is private;

   procedure Get_Normal
     (Mean   : in     Real;
      Sigma  : in     Real;
      N_Init : in out Normal_Initializer;
      Stream : in out State;
      Result :    out Real);
   --
   --  1. Must declare variable of type Normal_Initializer and pass it in. 
   --     The procedure Get_Normal does everything else for you.
   --
   --  The Gaussian distribution probability density:
   --
   --   f(X) = A * Exp (-(X-Mean)**2 / (2*Sigma**2))
   -- 
   --     Sigma = Standard_Deviation
   --     A     = 1.0 / (Sigma*Sqrt(2*Pi))       (normalization constant)
   -- 
   --  If Sigma=1, and Mean=0 then its usually called the
   --  Standard Normal distribution.

   function Normal_Probability
     (Mean  : in Real;   -- Mean    of random variable X
      Sigma : in Real;   -- Std Dev of random variable X
      X     : in Real)
      return Real;



   subtype Log_Normal_Initializer is Normal_Initializer;

   procedure Get_Log_Normal    -- outputs random variable X
     (Mean_Z  : in     Real;   -- Mean    of random variable Z = Log (X)
      Sigma_Z : in     Real;   -- Std Dev of random variable Z = Log (X)
      LN_Init : in out Log_Normal_Initializer;
      Stream  : in out State;
      Result  :    out Real);  -- X
   --
   --  1. Must declare variable of type Log_Normal_Initializer and pass it in. 
   --     The procedure Get_Log_Normal does everything else for you.
   --
   --  The Log_Normal distribution probability density for X:
   --
   --   f(X) = A * Exp (-(Log(X) - Mean_Z)**2 / (2*Sigma_Z**2)) / X
   --
   --   f(X) = 0 (for X <= 0)
   -- 
   --     Sigma_Z = Standard_Deviation of Z = Log (X)
   --     A       = 1.0 / (Sigma_Z * Sqrt (2*Pi))
   -- 
   --  If Z is a normally distributed Random Variable with (Mean_Z, Sigma_Z)
   --  then X = Exp (Z) is Log_Normal distributed with the distribution given
   --  above.  In terms of Z's Average and Std Deviation, (Mean_Z, Sigma_Z):
   --    Mean_X     = Exp (Mean_Z + Sigma_Z**2 / 2)
   --    Sigma_X**2 = Mean_X**2 * (Exp (Sigma_Z**2) - 1))
   -- 
   --  Suppose you have (Mean_X, Sigma_X) and you want (Mean_Z, Sigma_Z) of
   --  Z = Log(X), (the latter is the pair you plug into Get_Log_Normal above).
   --  The formula is
   --    Sigma_Z**2 = Log (1 + Sigma_X**2 / Mean_X**2))
   --    Mean_Z     = Log (Mean_X)  - 0.5 * Sigma_Z**2
   --

   function Log_Normal_Probability
     (Mean_Z  : in Real;   -- Mean    of random variable Z = Log (X)
      Sigma_Z : in Real;   -- Std Dev of random variable Z = Log (X)
      X       : in Real)
      return Real;
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  The Log_Normal probability density:
   --
   --   f(X) = A * Exp (-(Log(X) - Mean_Z)**2 / (2*Sigma_Z**2)) / X
   --
   --   f(X) = 0 (for X <= 0)
   -- 
   --     Sigma_Z = Standard_Deviation of Z, (where Z = Log (X)).
   --     A       = 1.0 / (Sigma_Z * Sqrt (2*Pi))


   procedure Get_Cauchy
     (A      : in     Real;
      Stream : in out State;
      Result :    out Real);
   --
   --  The Cauchy (Lorentzian) distribution probability density:
   --  
   --    f(X) = A / [(A*A + X*X) * Pi] -- normalized and scaled
   --
   --  Generates random deviates X in range (-inf, inf).


   procedure Get_Exponential
     (Mean   : in     Real;
      Stream : in out State;
      Result : out    Real);
   --
   --  1. Must have Mean > 0.0.  
   --     Raises contraint_Error if Mean is <= 0.0.
   --
   --  The Exponential distribution probability density:
   --  
   --   f(X) = Exp (-X / Mean) / Mean   for X > 0;  0 otherwise.
   --
   --   Generates a random deviate X in [0,inf). 



   procedure Get_Weibull
     (a      : in     Real;
      Stream : in out State;
      Result : out    Real);
   --
   --  The Weibull distribution probability density function:
   --  
   --   f(X) = a * X**(a-1) * Exp (-X**a)  if X > 0;  f(X) = 0 otherwise.
   --  
   --  If a=1 its Get_Exponential with Mean=1. Use Get_Exponential; much faster.
   --  If a=2 its Rayleigh distribution.       Use Get_Rayleigh; its faster.
   --  If a=0, raises contraint_Error.
   --  If a is too near 0, (or far from 1 in general) get Nan's or nonsense.


   procedure Get_Rayleigh
     (Stream : in out State;
      Result : out    Real);
   --
   --  The Rayleigh distribution probability density:
   --  
   --   f(X) = 2 * X * Exp (-X**2)  if X > 0;  f(X) = 0 otherwise.
   --  



   type Binomial_Initializer is private;

   procedure Get_Binomial
     (n      : in     Positive;
      p      : in     Real;
      B_Init : in out Binomial_Initializer;
      Stream : in out State;
      Result : out    Real);
   --
   --  1. Must declare variable of type Binomial_Initializer and pass it in.
   --     The procedure Get_Binomial does everything else for you.
   -- 
   --  2. Must have: 0 < p < 1.  (p = Bernoulli success probability.)
   -- 
   --  The Binomial distribution probability density:
   --  
   --   f(X) =  (n!/([X]!(n-[X])!)) * p^[X] * (1-p)^(n-[X]) 
   --        if 0 <= X <= n;  f(X) = 0 otherwise.
   --  
   --  Result is output as a float, but is always Integer valued.

   function Binomial_Probability
     (n : in Positive;
      k : in Integer;
      p : in Real)
      return Real;
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  Uses Log_Gamma to get:
   --
   --    [n!/(k!(n-k)!)] * p^k * (1-p)^(n-k)
   --    if 0 <= k <= n;
   --    returns 0 otherwise.
   --
   --    k < 0 returns 0
   --    k > n returns 0
   --
   --    p <= 0.0 raises Constraint_Error
   --    p >= 1.0 raises Constraint_Error



   type Neg_Binomial_Initializer is private;

   procedure Get_Neg_Binomial
     (r       : in     Real;
      p       : in     Real;
      NB_Init : in out Neg_Binomial_Initializer;
      Stream  : in out State;
      Result  :    out Real);
   --
   -- Result is a random deviate from distribution f_r(k) where f_r(k) is
   -- the probability of r successes and k failures in n = k+r Bernoulli trials.
   -- Assumes that the final trial is a success, and p = success probability.
   -- (r is not retricted to integer values; output Result is. Result is k-like.)
   --
   -- Slow for large r, (r >> 10).
   -- Slow for small p, (p < 0.1).
   --
   --    Must have:  r > 0.0
   --       r = the number of successes when r integer.
   --           The random deviate output (Result) is sampled
   --           from a distribution f_r(k) where f_r(k) is the
   --           probability that k failures and r successes
   --           are observed in a series of uncorrelated Bernoulli trials
   --           (with the final trial being a success).
   --    Must have:  0 < p < 1
   --       p = Bernoulli success probability
   --
   --  Result is output as a float, but is always Integer valued.


   function Neg_Binomial_Probability
     (r : in Real;
      k : in Integer;
      p : in Real)
      return Real;
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  Uses Log_Gamma to get:
   --
   --  [Gamma(r + k)/[(Gamma(r)*k!] * p^r * (1-p)^k
   --
   --    Must have:  r > 0.0
   --    Must have:  0 < p < 1
   --       p = Bernoulli success probability
   --
   -- Probability of r successes and k failures in n = k+r Bernoulli trials.
   -- Assumes that the final trial is a success, and p = success probability.
   --
   -- If r = 1, the distribution is the probability of success on the (k+1)th
   -- trial with k previous failures: geometric distribution, p*(1-p)^k.
   -- As r -> inf, keeping the Mean = r*(1-p)/p constant, you get the 
   -- Poissonian distribution. So its a large p limit, opposite of Binomial.



   subtype Poisson_Initializer is Binomial_Initializer;

   p_Shift : constant := -20;
   -- binomial is used to get Poisson, by setting p~2**(-20) and p*Mean = n.
   -- p is the binomial (Bernoulli) success probability: p = 2.0**p_Shift.
   -- p = -20 is stnd. If p=-20, then Max allowed Mean is < 2048, and you can
   -- sample for 2 days at least without detecting difference between Poisson
   -- and binomial.  If you set p=-23, then you can sample for 2 wks without 
   -- problem, but then the maximum allowed Mean is < 256.

   procedure Get_Poisson
     (Mean   : in     Real;
      P_Init : in out Poisson_Initializer;
      Stream : in out State;
      Result : out    Real);
   --
   --  The Poisson distribution probability mass function:
   --  
   --      f(k) = Mean^k * Exp (-Mean) / k!
   --
   --  Output of Poisson is integer valued, but floating point type.
   --  Output includes 0.
   --
   --  Must have Mean > 0
   --  Must have Mean < 2047.0  (if p_Shift = -20;  ie p = 2**(-20))
   --  Must have Mean < 256.0   (if p_Shift = -23;  ie p = 2**(-23))
   --
   --  If mean > 8 then routine uses Binomial with p = 2**(-20) (with large
   --  n so that Mean=n*p).  The binomial distribution agrees with Poisson
   --  with err ~ 5.0e-7 here. This discrepency is hard to 
   --  measure, but the routine should be thought of as single-precision.
   --  This discrepency can be reduced by a factor of 8 by reducing p
   --  by a factor of 8, (but max allowed Mean falls by a factor of 8).

   function Poisson_Probability
     (Mean : in Real;
      k    : in Integer)
      return Real;
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  The Poisson distribution (probability mass function):
   --  
   --      f(k) = Mean^k * Exp (-Mean) / k!
   --
   --  Negative k input is allowed (for convenience). 
   --  Output is 0 for k < 0.



   type Student_t_Initializer is private;

   procedure Get_Student_t
     (m                  : in     Positive;
      Student_t_Init     : in out Student_t_Initializer;
      Stream             : in out State;
      Result             : out    Real);
   --
   --  1. Must declare variable of type Student_t_Initializer and pass it in. 
   --     The procedure Get_Student_t does everything else for you.
   --
   --  2. Must have m >= 1.  (m = degrees of freedom of distribution.)
   --
   --  The Student_t distribution probability density:
   --  
   --     f(X) = (1 + X*X/m)^(-(m+1)/2) *
   --                     Gamma((m+1)/2) / [Sqrt (m*Pi) * Gamma(m/2)]
   --
   --  generates a random deviate from a t distribution 
   --  using Kinderman and Monahan's ratio method.

   function Student_t_Probability
     (m : in Positive;
      x : in Real)
      return Real;
   --
   --  A Probability density function.
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  Uses Log_Gamma to get: 
   --
   --  f(X) = Gamma((m+1)/2) * (1 + X*X/m)^(-(m+1)/2) / [Sqrt (m*Pi) * Gamma(m/2)]



   type Beta_Initializer is private;

   procedure Get_Beta
     (aa        : in     Real;
      bb        : in     Real;
      Beta_Init : in out Beta_Initializer;
      Stream    : in out State;
      Result    :    out Real);
   --
   --  1. Must declare variable of type Beta_Initializer and pass it in. 
   --     The procedure Get_Beta does everything else for you.
   --
   --  2. Must have aa > 0, bb > 0.
   --
   --  Get_Beta generates a random deviate in [0,1] from a beta distribution.
   --  Uses Cheng's log logistic method.
   --
   --  The Beta distribution probability density:
   --  
   --    f(X) = X**(aa-1) * (1-X)**(bb-1) *  
   --                       Gamma (aa + bb) / (Gamma (bb)*Gamma (aa))
   --
   
   function Beta_Probability
     (aa, bb : in Real;
      x : in Real)
      return Real;
   --
   --  NOT a random deviate.  (Used for testing mostly.)
   --
   --  f(x) = x**(aa-1) * (1-x)**(bb-1) *  
   --                       Gamma (aa + bb) / (Gamma (bb)*Gamma (aa))
   --
   --  x must be in range (0, 1)



   type Gamma_Initializer is private;

   procedure Get_Gamma
     (s          : in     Real;
      Gamma_Init : in out Gamma_Initializer;
      Stream     : in out State;
      Result     :    out Real);
   --
   --  1. Must declare variable of type Gamma_Initializer and pass it in. 
   --     The procedure Get_Gamma does everything else for you.
   --
   --  2. Must have s > 0.
   --     s = Shape parameter of Gamma distribution.
   --
   --  Generates a random deviate in [0,infinity) from a gamma distribution.

   function Gamma_Probability
     (s : in Real;
      x : in Real)
      return Real;
   --
   --  f(x) = x**(s-1) * Exp (-x)  / Gamma (s) 
   --       = 0 if x < 0.
   --
   --  (where s = Gamma shape parameter).
   --  Must have s > 0.
   --  NOT a random deviate.  (Used for testing mostly.)



   subtype Chi_Initializer is Gamma_Initializer;

   procedure Get_Chi_Squared
     (Degrees_of_Freedom : in     Real;
      Chi_Init           : in out Chi_Initializer;
      Stream             : in out State;
      Result             :    out Real);
   --
   --  1. Must declare variable of type Chi_Initializer and pass it in. 
   --     The procedure Get_Chi_Squared does everything else for you.
   --
   --  2. Must have Degrees_of_Freedom > 0.
   --
   --  Generates a random deviate in [0,infinity) from a Chi-Sq distribution.


   function Chi_Squared_Probability
     (Degrees_of_Freedom : in Real;
      x : in Real)
      return Real;
   --
   --  f(x) = (1 / 2) * (x / 2)**(s-1) * Exp (-x / 2)  / Gamma (s) 
   --       = 0 if x < 0.
   --
   --  (where s = 0.5 * Degrees_of_Freedom).
   --  NOT a random deviate.  (Used for testing mostly.)



   -- USING Get_Multivariate_Normal:
   --
   -- procedure Get_Multivariate_Normal is harder to use than the 1-dimensional
   -- routines.  You have to remember the following:
   -- 1.  You need a positive definite Covariance matrix.
   -- 2.  Declare it type Matrix (a..b, a..b) where a and b are type Positive.
   -- 3.  Declare Means : Vector(a..b), same range as Matrix, and initialize Means.
   -- 4.  Use procedure Choleski_Decompose to get the LU decomp. of Covariance.

   subtype MV_Normal_Initializer is Normal_Initializer;

   type Vector is array (Positive range <>) of Real;
   type Matrix is array (Positive range <>, Positive range <>) of Real;

   procedure Choleski_Decompose 
     (Covariance       : in     Matrix;
      LU_of_Covariance :    out Matrix); -- Choleski Decomp of Covariance matrix.

   procedure Get_Multivariate_Normal 
     (Mean             : in     Vector;
      LU_of_Covariance : in     Matrix;
      MV_Init          : in out MV_Normal_Initializer;
      Stream           : in out State;
      Result           :    out Vector);
   --
   --  To use Get_Multivariate_Normal:
   --      put a Positive Definite Covariance matrix into
   --      Choleski_Decompose to get Sqrt_Covariance.
   --
   --  Must have 
   --      Mean'First  = Covariance'First(1) = Covariance'First(2)
   --      Mean'Last   = Covariance'Last(1)  = Covariance'Last(2)
   --      Mean'Length > 1 
   --  So use: 
   --      Mean       : Vector (1..n);
   --      Covariance : Matrix (1..n, 1..n);
   --
   --  Must initialize: Mean.

   function Multivariate_Normal_Probability
     (Mean             : in Vector;   -- Mean  of random variables X
      LU_of_Covariance : in Matrix;   -- L of LU decomp of Covariance matrix
      X                : in Vector)
      return Real;


   procedure Test_Choleski;


private

   Half  : constant Real := +0.5;
   Zero  : constant Real := +0.0;
   One   : constant Real := +1.0;
   Two   : constant Real := +2.0;
   Three : constant Real := +3.0;
   Four  : constant Real := +4.0;
   Five  : constant Real := +5.0;
   Eight : constant Real := +8.0;
   Sixteen : constant Real := +16.0;
   Quarter : constant Real := +0.25;
   Two_to_the_Ninth : constant Real := +512.0;

   type Binomial_Initializer is
   record
      n             : Positive := Positive'First;
      r0            : Integer  := 0;
      p             : Real     := Half;
      p_r           : Real     := Zero;
      odds_ratio    : Real     := Zero;
      Uninitialized : Boolean  := True;
   end record;

   type Student_t_Initializer is
   record
      m             : Positive := Positive'First;
      a, f, g       : Real     := Zero;
      Uninitialized : Boolean  := True;
   end record;

   type Beta_Initializer is
   record
      Alpha, Beta   : Real    := Zero;
      d, f, h, t, c : Real    := Zero;
      Swap          : Boolean := False;
      Uninitialized : Boolean := True;
   end record;
   
   type Gamma_Initializer is
   record
      s, p, c, uf, vr, d : Real    := Zero;
      Uninitialized      : Boolean := True;
   end record;
   
   type Neg_Binomial_Initializer is
   record
      Reciprocal_Log_p1 : Real    := Zero;
      Reciprocal_Log_q1 : Real    := Zero;
      p                 : Real    := Half;
      Uninitialized     : Boolean := True;
   end record;

   type Normal_Initializer is
   record
      Mean          : Real    := Zero;
      Sigma         : Real    := Zero;
      X2            : Real    := Zero;
      Uninitialized : Boolean := True;
   end record;

   Max_Allowed_Real : constant Real := Two**(Real'Machine_Emax-32);
   Min_Allowed_Real : constant Real := Two**(Real'Machine_Emin+32);

end Disorderly.Random.Deviates;
