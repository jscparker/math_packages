
-----------------------------------------------------------------------
-- package body A_Legendre. Data structure for Associated Legendre Polynomials.
-- Copyright (C) 2018 Jonathan S. Parker
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted, provided that the above
-- copyright notice and this permission notice appear in all copies.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
---------------------------------------------------------------------------

with Factorial;

package body A_Legendre is

   package F is new Factorial (Real); use F;

   Zero : constant Real := +0.0;
   Half : constant Real := +0.5;
   One  : constant Real := +1.0;
   Two  : constant Real := +2.0;
   Log_base_e_of_2 : constant Real := 
     +0.69314718055994530941723212145817656807550013436025525412068;

   function X_Lower_Bound return Real is
   begin
      return -One;
   end;

   function X_Upper_Bound return Real is
   begin
      return One;
   end;

   -------------------
   -- Log_of_1_plus --
   -------------------

   --  More accurate than using Log (1 + x) for Abs x << 1.

   function Log_of_1_plus
      (x : Real)
      return Real
   is
      u   : constant Real := One + x;
      Sqrt_Eps : constant Real := Two ** (-Real'Machine_Mantissa / 2 - 6);
   begin
      if u <= Zero then
         raise Constraint_Error;
      end if;

      -- Use Log(1+x) = x - x^2/2 + x^3/3 - ... = x*(1 - x/2 + x^2/3 ...)
      -- So if x is somewhat smaller than Sqrt (Real'Epsilon) then 1 + x^3/3 = 1:

      if Abs (u - One) < Sqrt_Eps then
         return x - Half * x * x;
      end if;

    --return Log(u) * x / (u - One); -- more accurate?  (u /= One; see above).
      return Log(u);  

   end Log_of_1_plus;

   -----------
   -- Alpha --
   -----------

   --  Alpha (k, m, X) = X * (2*(m+k) - 1) / k
   --
   function Alpha (k : Base_Poly_ID; m : Real; X : Real) return Real is
      Result  : Real;
      Real_k         : constant Real := +Real (k);
      Real_k_plus_m  : constant Real := Real_k + m;
   begin
      if (m < Zero or k < 1) then raise Constraint_Error; end if;
      Result := X * (Real_k_plus_m + Real_k_plus_m - One) / Real_k;
      return Result;
   end Alpha;

   ----------
   -- Beta --
   ----------

   --  Beta (k, m, X)  = -(k + 2*m - 1) / k
   --
   function Beta (k : Base_Poly_ID; m : Real; X : Real) return Real is
      Real_k : constant Real := Real (k);
   begin
      if (m < Zero or k < 1) then raise Constraint_Error; end if;
      return -(Real_k + m + m - One) / Real_k;
   end Beta;

   ---------
   -- Q_0 --
   ---------

   --  Q_0 (m, X) = (-1)**m * Sqrt(1-X*X)**m
   --
   function Q_0 (m : Real; X : Real) return Real is
      Arg, Factor, Result : Real;
      m_int : constant Integer := Integer (m);  --  Important init.
   begin

      if m_int   = 0   then return One            ; end if;
      if Abs (X) = One then return Zero           ; end if;

      if m_int < 0     then raise Constraint_Error; end if;
      if Abs (X) > One then raise Constraint_Error; end if;

      -- Result := (-Sqrt ((One - X) * (One + X))) ** m_int;
   
      Arg := 0.5 * m * Log_of_1_plus(-X*X); -- Arg always < 0

      if Abs (Arg) > 600.0 then  -- Exp(-600.0) ~  10^(-262)
         Result := Zero;
      else
         --  Factor = (-1)**m_int:
         if 2*(m_int/2) = m_int then 
            Factor := One; 
         else 
            Factor := -One; 
         end if;
         Result := Factor * Exp (Arg);
      end if;

      return Result;
   end Q_0;

   -----------------
   -- Poly_Weight --
   -----------------

   function Poly_Weight (X : Real) return Real is
   begin
      return One;
   end;

   --------------------------
   -- Normalization_Factor --
   --------------------------

   --
   --  Int (Q_k(m, X) * Q_k(m, X) * W(X))
   --          = ((k+2*m)! / (k!*(2*m-1)!!**2)) / (k + m + 0.5)
   --
   --  Function should be multiplied by the inverse Sqrt of the above
   --  quantity in order to normalize the Legendre Function generated by the
   --  recurrance relation.  The function returns the inverse Sqrt of the
   --  above quantity.
   --
   --  7!! = 7*5*3*1
   --  (2*m-1)!! = (2m)!/(m!2^m) so we can (and should) use log_factorial
   --  to do this.
   --
   --  Ratio = k! * (2*m-1)!!**2) * (k + m + 0.5) / (k+2*m)!
   --        = k! * (2m)! * (2m)!  * (k + m + 0.5) / [2^(2m) * m! * m! * (k+2*m)!]
   --
   --  Want Normalization_Factor to be the Sqrt (Ratio) of the above.
   --
   --  Perceptibly less accurate than alternative (see below), but 
   --  very safe and possibly faster.
   --
   function Normalization_Factor_0
     (k : Base_Poly_ID;
      m : Real)
      return Real
   is
      Log_Ratio : Real := Zero;
      m_int     : constant Natural := Natural (m);
      k_int     : constant Natural := Natural (k);
   begin
      if (m_int < 0 or k < 0) then raise Constraint_Error; end if;

      --  if m = 0, then Log_Ratio is already correctly set to 0.0.

      if m_int > 0 then

         -- leaving out the (k + m + 0.5) for now:

         Log_Ratio := Log_Factorial (2*m_int) * Two - Log_Factorial (m_int) * Two;
         Log_Ratio := Log_Ratio +
                         Log_Factorial (k_int)
                      -  Log_Factorial (k_int + 2*m_int)
                      -  Log_base_e_of_2 * m * Two;

      end if;

      return Sqrt (Real (k) + m + Half) * Exp (Half * Log_Ratio);

   end Normalization_Factor_0;

   --  Method is much less safe at high l, m ?

   function Norm_more_accurate_but_Slower
     (k : Base_Poly_ID;
      m : Real)
      return Real
   is
      Two_m_minus_1_plus_k, Two_m_minus_1 : Real;
      Real_k        : constant Real := +Real (k);
      Real_k_plus_m : constant Real :=  Real_k + m;
      Ratio  : Real := One;
      Result : Real := One;
      m_int  : constant Integer := Integer (m);
   begin
      if (m_int < 0 or k < 0) then raise Constraint_Error; end if;

      --  Get 1 / Ratio = (2*m-1)!!**2 * k! / (2*m + k)!.
      --  if m = 0, then Ratio is already 1.0.

      for m_index in 1 .. m_int loop
         Two_m_minus_1        := +Real (2 * m_index - 1);
         Two_m_minus_1_plus_k := Two_m_minus_1 + Real_k;
         Ratio := Ratio / Sqrt (Two_m_minus_1_plus_k*(Two_m_minus_1_plus_k + One));
         Ratio := Ratio * Two_m_minus_1;
      end loop;

      Result := Ratio * Sqrt (Real_k_plus_m + Half);

      return Result;
   end Norm_more_accurate_but_Slower;

   function Normalization_Factor
     (k : Base_Poly_ID;
      m : Real)
      return Real
   renames Norm_more_accurate_but_Slower;

end A_Legendre;
