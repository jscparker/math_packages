
-- package Clenshaw
--
-- Clenshaw's formula is used to evaluate functions Q_k (X), and 
-- summations over functions Q_k (X), where the functions Q_k (X) 
-- are defined by recurrance relations of the sort:
--
--        Q_0  =  some given function of X
--        Q_1  =  Alpha(1, X) * Q_0(X)
--        Q_k  =  Alpha(k, X) * Q_k-1(X) + Beta(k, X) * Q_k-2(X)    (k > 1)
--
-- The procedure "Sum" evaluates the sum
--                  n
--        F_n(X) = SUM ( C_k * Q_k(X) )
--                 k=0
--
-- where the coefficients C_k are given quantities, like Alpha, Beta, Q_0, Q_1.
-- Procedure "Evaluate_Qs" calculates the function Q_k, a special case
-- of the sum above.  Clenshaw's method is usually more accurate and less
-- unstable than direct summations of F_n.
--
-- The most common application of this algorithm is in the construction
-- of orthogonal polynomials and their sums.  But notice that the functions
-- functions Q_k need not be orthogonal, and they need not be polynomials.
-- In most cases, though, the Q_k are orthogonal polynomials.
-- Common cases are Hermite, Laguerre, Chebychev, Legendre,
-- and Gegenbauer polynomials.
--
-- WARNING: 
--
-- These functions are not the same as the Gram-Schmidt polynomials.
-- Gram-Schmidt polys are orthogonal on a discrete set of points, and 
-- form a complete for function defined on that discrete set of points.
-- The orthogonality of the following functions is respect integration on
-- an interval, not summation over a discrete set of points. So these
-- functions don't form a complete set on a discrete set of points
-- (unlike the discrete polys generated by a gram-schmidt method, or 
-- the sinusoids in a discrete Fourier transform.)
--
-- EXAMPLES.
--
-- Chebychev Polynomials of the first kind:
--             Q_0(X)     = 1
--             Q_1(X)     = X
--             Q_k(X)     = 2X*Q_k-1(X) - Q_k-2(X)    (k > 1)
--             Alpha(k,X) = 2*X                       (k > 1)
--             Alpha(k,X) = X                         (k = 1)
--             Beta(k,X)  = -1
-- They are orthogonal on the interval (-1,1) with
-- weight function W(X) = 1.0 / SQRT(1 - X*X).
-- Normalizing integral: Integral(Q_n(X) * Q_n(X) * W(X)) = Pi/2 for n>0
-- Normalizing integral: Integral(Q_n(X) * Q_n(X) * W(X)) = Pi   for n=0
--
-- Chebychev Polynomials of the 2nd kind:
--             Q_0(X)     = 1
--             Q_1(X)     = 2*X
--             Q_k(X)     = 2X*Q_k-1(X) - Q_k-2(X)
--             Alpha(k,X) = 2*X
--             Beta(k,X)  = -1
-- They are orthogonal on the interval (-1,1) with
-- weight function W(X) = SQRT(1 - X*X).
-- Normalizing integral: Integral(Q_n(X) * Q_n(X) * W(X)) = Pi/2
--
-- Legendre:   Q_0(X)     = 1
--             Q_1(X)     = X
--             Q_k(X)     = ((2*k-1)/k)*X*Q_k-1(X) - ((k-1)/k)*Q_k-2(X)
--             Alpha(k,X) = X*(2*k-1)/k
--             Beta(k,X)  = -(k-1)/k
-- They are orthogonal on the interval [-1,1] with
-- weight function W(X) = 1.
-- Normalizing integral: Integral(Q_n(X) * Q_n(X) * W(X)) = 2/(2n+1)
--
-- Associated Legendre(m, k):   ( k must be greater than m-1 )
--             Q_m(X)     = (-1)**m * (2m-1)!! * Sqrt(1-X*X)**m
--             Q_m+1(X)   = X * (2*m + 1) * Q_m(X)
--             Q_k(X)     = ((2*k-1)/(k-m))*X*Q_k-1(X) - ((k-1+m)/(k-m))*Q_k-2(X)
--             Alpha(k,X) = X*(2*k-1)/(k-m)
--             Beta(k,X)  = -(k-1+m)/k
-- They are orthogonal on the interval [-1,1] with
-- weight function W(X) = 1.
-- Normalizing integral:
--        Integral(Q_n(X) * Q_n(X) * W(X)) = 2*(n+m)! / (2*n+1)*(n-m)!)
--
-- Hermite:    Q_0(X)     = 1
--             Q_1(X)     = 2*X
--             Q_k(X)     = 2*X*Q_k-1(X) - 2*(k-1)*Q_k-2(X)
--             Alpha(k,X) = 2*X
--             Beta(k,X)  = -2*(k-1)
-- They are orthogonal on the interval (-infinity, infinity) with
-- weight function W(X) = Exp (-X*X).
-- Normalizing integral: Integral (Q_n(X)*Q_n(X)*W(X)) = n!(2**n)*Sqrt(Pi)
--
-- Laguerre:   Q_0(X)     = 1
--             Q_1(X)     = 1 - X
--             Q_k(X)     = (2*k - 1 - X)*Q_k-1(X) - (k-1)*(k-1)*Q_k-2(X)
--             Alpha(k,X) = 2*k - 1 - X
--             Beta(k,X)  = -(k-1)*(k-1)
-- They are orthogonal on the interval (0,infinity) with
-- weight function Exp(-X).
-- Normalizing integral: Integral (Q_n(X)*Q_n(X)*W(X)) = Gamma(n+1)/n!
--
-- Generalized Laguerre:
--             Q_0(X)     = 1
--             Q_1(X)     = 1 - X
--             Q_k(X)     = ((2*k-1+a-X)/k)*Q_k-1(X) - ((k-1+a)/k)*Q_k-2(X)
--             Alpha(k,X) = (2*k - 1 + a - X) / k
--             Beta(k,X)  = -(k - 1 + a) / k
-- They are orthogonal on the interval (0,infinity) with
-- weight function W(X) = (X**a)*Exp(-X).
-- Normalizing integral: Integral (Q_n(X)*Q_n(X)*W(X)) = Gamma(n+a+1)/n!
--
--
-- PROCEDURE Evaluate_Qs
--
-- The procedure calculates the value of functions Q_k at points
-- X for each k in 0..Poly_ID.  These are returned in the array
-- Q in the range 0..PolyID.
--
-- In most cases only the value of Q_k (X) at k = Poly_ID is desired.  This
-- is returned as Q(k), where k = Poly_ID, the ID of the desired function.
-- The values of the other Q's are returned (in the same array
-- Q, at the appropriate index) because they are calculated along the
-- way, and may be useful also.
--
-- WARNING: 
--
-- The functions Q_k generated by this routine are usually
-- *un-normalized*.  Frequently, values of the normalized Q_k
-- are desired.  The normalization factors are not given
-- by this package.  They are given in most cases by the
-- procedures that use this package, and by standard reference
-- sources.  These factors are usually k dependent, so you
-- must multiply each element of Q(1..Poly_ID) by a different
-- number to get an array of values of the normalized functions.
--
-- FUNCTION Sum
--
-- This function sums the functions Q_k (at X) with coefficients given
-- by the array C.      The result is returned as the function value.
-- This function is also a fast and efficient way of getting the
-- value of Q_k at X.  Just let C = 0 everywhere, except at k.  Let
-- the of C at k be C(k) = 1.0.  then the function returns Q_k(X).
--
-- Notes on the algorithm.
--
-- We want to evaluate
--                    n
--          F_n(X) = SUM ( C_k * Q_k(X) )
--                   k=0
--
-- where Q is defined by
--
--          Q_k  =  Alpha(k, X) * Q_k-1 + Beta(k, X) * Q_k-2     (k > 1)
--
-- This package calculates F_n by the following formula
--
--     (*)  F_n(X) = D_0*Q_0(X) + D_1*(Q_1(X) - Alpha(1,X)*Q_0(X)).
--
-- where the D_k are functions of X that satisfy:
--
--          D_n+2 = 0
--          D_n+1 = 0
--          D_k   = C_k + Alpha(k+1,X) * D_k+1(X) + Beta(k+2,X) * D_k+2(X)
--
-- The proof of (*) is straightforward.  Solve for C_k in the equation for
-- D_k above and plug it into the sum that defines F_n to get
--
--         n
--  F_n = SUM (D_k - Alpha(k+1)*D_k+1 - Beta(k+1)*D_k+2 ) * Q_k
--        k=0
--                               n
--  F_n = D_0*Q_0 + D_1*Q_1  +  SUM ( D_k * Q_k )
--                              k=2
--                        n
--  -Alpha(1)*D_1*Q_0 +  SUM (-Alpha(k) * D_k * Q_k-1 )
--                       k=2
--                        n
--                    +  SUM (-Beta(k) * D_k * Q_k-2 ).
--                       k=2
--
-- Now factor out D_k from the three SUM terms above, and notice
-- that what remains is just the recurrance relation that defines
-- Q_k for k > 0.  It evaluates to zero, leaving
--
--     F_n(X) = D_0*Q_0(X)
--
-- (It should be clear that this process can be easily generalized
-- to recurrance relations in which Q_k depends on the previous 3 Q's.
--
--     Q_0  =  some given function of X
--     Q_1  =  some given function of X
--     Q_2  =  some given function of X
--     Q_k  =  Alpha(k,X)*Q_k-1(X) + Beta(k,X)*Q_k-2(k,X) + Gamma*Q_k-3(X)
--
-- The SUM's above should start at k=3, but the derivation is identical.)
--
-- Finally notice that in special cases this simplifies further.
-- In many cases, particularly the orthogonal polynomials,
-- Q_0 is 1, so that F_n = D_0.
--

generic

   type Real is digits <>;
   --  This package only sums functions of real variables.

   type Base_Poly_Index_Type is range <>;

   Poly_Limit : Base_Poly_Index_Type;

   with function Alpha 
     (k         : Base_Poly_Index_Type;
      Parameter : Real;
      X         : Real) 
      return      Real;
      
   with function Beta 
     (k         : Base_Poly_Index_Type;
      Parameter : Real;
      X         : Real)
      return      Real;
      
   with function Q_0  
     (Parameter : Real;
      X         : Real) 
      return      Real;

package Clenshaw is

   subtype Poly_ID_Type is Base_Poly_Index_Type range 0 .. Poly_Limit;
   --  The index k.  k always starts a 0.

   type Poly_Values is array(Poly_ID_Type) of Real;

   procedure Evaluate_Qs
     (X                : in     Real;
      Q                : in out Poly_Values;
      Max_Poly_ID      : in     Poly_ID_Type;
      P                : in     Real          := 0.0;
      No_Of_Iterations : in     Positive      := 1);
   --  Get Q_0(X), Q_1(X) ... Q_m(X) where m = Max_Poly_ID.
   --  P is the parameter in Alpha and Beta.

   type Coefficients is array(Poly_ID_Type) of Real;

   function Sum 
     (X                : in Real;
      C                : in Coefficients;
      Sum_Limit        : in Poly_ID_Type;
      P                : in Real          := 0.0;
      No_Of_Iterations : in Positive      := 1)   
      return                Real;
   --  Sum the polys Q times the Coefficients: SUM (Q_k * C_k)
   --  P is the parameter in Alpha and Beta.

end Clenshaw;
